{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 TimesNewRomanPSMT;\f1\fnil\fcharset0 HelveticaNeue-Bold;\f2\fnil\fcharset0 .SFNS-Regular;
}
{\colortbl;\red255\green255\blue255;\red14\green14\blue14;}
{\*\expandedcolortbl;;\cssrgb\c6700\c6700\c6700;}
\margl1440\margr1440\vieww18200\viewh14220\viewkind0
\pard\tqr\tx440\tx600\li600\fi-600\sl324\slmult1\sb240\partightenfactor0

\f0\fs28 \cf2 	1.	
\f1\b Minimize Instance Creation
\f2\b0 \
Avoid creating multiple redundant instances of classes or objects. Reuse existing instances whenever possible to conserve memory and improve performance.\

\f0 	2.	
\f1\b Promote Code Reuse and Modularity
\f2\b0 \
Encapsulate reusable logic into functions, methods, or modules. Avoid duplicating code to reduce bugs and simplify maintenance.\

\f0 	3.	
\f1\b Optimize Data Structures and Indexing
\f2\b0 \
Choose appropriate data structures for efficient lookup, insertion, and deletion. Use indexing or caching to speed up repeated operations.\

\f0 	4.	
\f1\b Ensure Proper Resource Management
\f2\b0 \
Manage resources like memory, file handles, or connections carefully. Release or close them promptly when no longer needed to prevent leaks.\

\f0 	5.	
\f1\b Prefer Simplicity and Clarity
\f2\b0 \
Generate straightforward and readable code. Avoid overcomplicated or clever solutions that sacrifice maintainability or readability.\

\f0 	6.	
\f1\b Follow Consistent Naming and Style Conventions
\f2\b0 \
Use clear, descriptive names and adhere to language-specific style guides for formatting, indentation, and structure.\

\f0 	7.	
\f1\b Avoid Side Effects When Possible
\f2\b0 \
Write functions with minimal side effects to enhance predictability and ease testing.\

\f0 	8.	
\f1\b Implement Lazy Initialization and Caching
\f2\b0 \
Delay costly operations until necessary and cache results to avoid redundant computations.\

\f0 	9.	
\f1\b Handle Edge Cases and Errors Gracefully
\f2\b0 \
Anticipate invalid inputs or failure scenarios and add appropriate error handling to maintain robustness.\

\f0 	10.	
\f1\b Define Clear Termination Conditions
\f2\b0 \
For loops and recursion, always specify well-defined exit conditions to prevent infinite loops.\

\f0 	11.	
\f1\b Encapsulate State Properly
\f2\b0 \
Use class or module-level encapsulation to protect internal state and avoid unintended mutations.\

\f0 	12.	
\f1\b Maintain Separation of Concerns
\f2\b0 \
Keep different responsibilities in separate functions or classes to improve modularity and testability.\

\f0 	13.	
\f1\b Document Complex Logic Clearly
\f2\b0 \
Add comments or docstrings explaining non-obvious algorithms, assumptions, or decisions.\

\f0 	14.	
\f1\b Favor Immutable Data When Feasible
\f2\b0 \
Use immutable variables or data structures where possible to reduce bugs from unintended changes.\

\f0 	15.	
\f1\b Avoid Global Variables Unless Necessary
\f2\b0 \
Minimize reliance on globals to reduce coupling and improve code modularity.\

\f0 	16.	
\f1\b Adhere to Language-Specific Best Practices
\f2\b0 \
Follow idiomatic patterns and community-accepted standards for the target programming language.}